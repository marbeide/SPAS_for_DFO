---
title: "SPAS_data_formatting_&_run"
author: "Michael Arbeider, Michael.Arbeider@dfo-mpo.gc.ca (or marbeide@gmail.com)"
date: '2019-11-25'
output:
  rmarkdown::html_vignette: default
  html: default
created: '2018-11-26'
---

# Intro to R Studio and Using this .Rmd script
This "R Markdown" (.Rmd) files works best when used in R studio. If you are unfamiliar with R Studio, this book: https://bookdown.org/ndphillips/YaRrr/the-four-rstudio-windows.html has a good intro to the different Windows and features as well as other info about using R.

This Markdown file contains a function that produces the SPAS input file from the MACH2 xlsm file WB5PopEstimator.

The steps to running this markdown file are as follows:
1) Install & Load Packages
1.5) Set Working Directory (to location of MACH2 files for specific project-year) IF-NEED-BE
2) Read in Data
3) Check and Rename Columns
4) Run function code chunk #1
5) Specify Strata and Sex Correction
6) Validate numbers with PopEstimatorPRT in WB5PopEstimator.xlsm
7) Locate SPAS2_input.csv(s) in MACH2 folder (working directory) & move to desired folder location
8) Double Check SPAS2_input.csv(s) by opening them
9) Run function code chunk #2
10) Run SPAS!

The format of the SPAS_R_input.csv(s) (one will be _Female and one _Male) is a matrix of s+1 by t+1 (where s = number of application strata and t = number of recovery strata)
Cell s+1 by t+1 will always be 0
Column t+1 = contains the number of animals marked in each row stratum but not recovered in any column stratum.
Row s+1 = contains the total number of UNMARKED animals recovered in column stratum it's in.
All of the other cells are the number of recovered MARKED individuals of stratum s by t

!!!For first time .Rmd users!!!
To Run code, either click the green "play" button for a given "chunk"" or click to the line you want to run and click "Run" at the top of this pane or click crt+enter if on a pc or cmd+enter on a mac.
Chunks are created by '''{r} and ended by '''

Subsequent Sections will have instructions

```{r}
rm(list=ls()) # clears global environment if need-be, this can generally be ignored
```

#1 Install & Load Packages
Delete the # in front of install.packages() if you do not have "tidyverse" or "openxlsx" installed
You can check if they are installed by clicking the "Packages" tab in the Plots pane (often bottom right pane) and scrolling down (packages are sorted alphabetically)

```{r}
#install.packages("tidyverse")
#install.packages("openxlsx")
```

## Install or Update SPAS
Sometimes this install will prompt you to install other packages. Type 1 into the console to select all packagess and install them.
IF some packages fail to install, try the following:
  a) Use the "Update" button in the "Packages" tab of the "Files/Plots/Packages/Help" Window. Click the button, then select the packages that need to be updated. Click the Update button.
Remove the packages and re-install them.
  b) Or try: remove.packages(“package name”) in the console (enter package name and then click enter) and then use install.packages(‘package name’) to re-install it.
  c) If the above doesn’t work, try: go to your Library folder on your computer and delete the files. You can find your library location by clicking the “Install” button and seeing where the packages are being installed by default. Navigate to the folder and delete the package folder(s). Use install.packages() or Install button to re-install the problem package.
```{r}
# ALWAYS run the below line to see if there are updates to SPAS in GitHub
devtools::install_github("cschwarz-stat-sfu-ca/SPAS", dependencies = TRUE,
                        build_vignettes = TRUE)
```

##Library other packages
Press play!
```{r}
library(tidyverse)
library(openxlsx)
library(SPAS)
# if there are R version errors, you will likely have to ignore them because we can't update R to the latest version through the Software Center
```

#1.5 Set Working Directory
This step is only needed if your working directory isn't where your files are!
```{r}
getwd() # you can either check with this or by looking at the Files tab in the plots window
```

Since the files are probably all in different places per project-year, the easiest way to set this is likely by going into the "Session" tab, "Set Working Directory", "Choose Directory..." OR press Ctrl+Shift+H

#2 Read In Data
Read in data from "WB5PopEstimator.xlsm"
The following chunk reads in the "AppRec(PostStress)" and "Recovery(Adjusted)" sheets as long as they have not changed position in MACH2.
i.e. if there have been changes to MACH2, you will need to change the numbers after "sheet = " so that they match the above respectively

If the WB5PopEstimator file name has changed, you will have to modify it accordingly in this chunk
```{r}
app <- read.xlsx("WB5PopEstimator.xlsm", sheet = 4, detectDates = F)
rec <- read.xlsx("WB5PopEstimator.xlsm", sheet = 5, detectDates = F)
```

# 3 Check and Rename Columns

The next chunk renames those troublesome strata column names with "=" and " ' " and other symbols that confuse R.

!!!Need to check if these are in fact the columns present and in the right place!!!

Run this chunk
```{r}
colnames(app)
```

Where is your first Strata column names? i.e. what is the column number?
Where is you last column name?

Here is a quick check if you are doing Chinook and haven't changed the number or type of default strata in MACH2
```{r}
# is "Application.strata:.=Days" in position 37 & "Application.strata:.extra2" in 47?
colnames(app)[37] == "Application.strata:.=Days"
colnames(app)[42] == "Application.strata:.extra1"
colnames(app)[47] == "Application.strata:.extra2" 
# if all are TRUE, you likely do not need to modify the below, if FALSE, you will have to find the correct positions
```

If your column names looks like they match the names below, then just run that chunk.
Otherwise, you may have to renumber which columns are being changed and what your new column names are.

Please only use letters, numbers, and underscores in your names.
The most essential column names to change are the ones that you are going to use. You may ignore changing the rest if desired.

```{r}
colnames(app)[37:47] <- c("app_equal_days", "app_equal_effort", "app_equal_numbers",
                          "app_equal_area", "app_equal_recaps", "app_equal_extra1",
                          "rec_equal_days", "rec_equal_effort", "rec_equal_numbers",
                          "rec_equal_area", "app_equal_extra2")
```

Rinse and repeat for Recovery dataframe!

Check
```{r}
colnames(rec)
```

Quick Check if MACH2 Default
```{r}
colnames(rec)[17] == "Recovery.strata:.=Days"
colnames(rec)[20] == "Recovery.strata:.area"
colnames(rec)[23] == "Recovery.strata:.extra2"
```

Where you actually change stuff if need be
```{r}
colnames(rec)[17:23] <- c("rec_equal_days", "rec_equal_effort", "rec_equal_numbers",
                          "rec_equal_area", "rec_equal_area2", "rec_equal_extra1",
                          "rec_equal_extra2")
```

#4 Run Function code
The function SPAS2.input.file() will do all the wonderful things your pivot tables used to!
This includes distributing secondary marked only fish across the application strata (s)

And it adds the sex correction to the applied tags in the form of 
Female correction = 1 - Value, 
Male Correction = 1 + Value.

Press the play button (right hand side) and then minimize with the arrow by the line nubmers (on the left hand side)
DO NOT EDIT unless making a commit to the GitHub
```{r}
SPAS2.input.file <- function(appdat, recdat, app.strata, combine.app,
                              rec.strata, combine.rec,
                              sex.correction, name, jacks){ 
  
  # If combine.app is TRUE, this will unite the strata for subsequent grouping
  if(combine.app == TRUE) combine.by.a <- enquo(app.strata)
  if(combine.app == TRUE) appdat <- appdat %>% unite("app.strata", !!combine.by.a)
  if(combine.app == TRUE) app.strata = quo(app.strata)
  # If combine.app is FALSE, this will just wrap the strata in qosure o that subsequent functions can read it as a column name
  if(combine.app == FALSE) app.strata <- enquo(app.strata)
  
  # If combine.rec is TRUE, this will unite the strata for subsequent grouping
  if(combine.rec == TRUE) combine.by.r <- enquo(rec.strata)
  if(combine.rec == TRUE) recdat <- recdat %>% unite("rec.strata", !!combine.by.r)
  if(combine.rec == TRUE) appdat <- appdat %>% unite("rec.strata", !!combine.by.r)
  if(combine.rec == TRUE) rec.strata = quo(rec.strata)
  # If combine.rec is FALSE, this will just wrap the strata in qosure o that subsequent functions can read it as a column name
  if(combine.rec == FALSE) rec.strata <- enquo(rec.strata)
  
  correction = sex.correction
  
    # create sex corrected applications~app strata  
  sex.cor <- filter(appdat, Application.Sex %in% c("M", "F")) %>% 
    group_by(!!app.strata) %>% # creating a row for each app strata
    summarise(applied = n()) %>% # n() plus group by does the same thing as count()
    mutate(applied = applied*(correction)) # the sex correction per strata
  
  # This function is two sets of the "same" code, one for Males and one for Females
  # Male code is denoted by m.
  # Female code is denoted by f.
  # Only the first set of steps is annotated
  
  # add sex corrected applications~app strata  
  m.cor.app <- filter(appdat, Application.Sex == "M") %>% 
    group_by(!!app.strata) %>% # creating a row for each app strata
    summarise(applied = n()) %>% # n() plus group by does the same thing as count()
    mutate(applied = applied+sex.cor$applied) # adding the sex correction
  
  # create sum of Untagged fish recovered per recovery strata
  m.unt.rec <- recdat %>% 
    group_by(!!rec.strata) %>%
    summarise(untagged.rec = sum(Untagged.Males))
  
  # create column for total recoveryies and proportion recovered in each strata that will be used for redistributing secondary marked fish to application strata proportional to the recovery strata they were found in
  m.total.rec <- recdat %>% 
    group_by(!!rec.strata) %>%
    summarise(total.rec = sum(Tagged.Males + Untagged.Males)) %>%
    mutate(pr = total.rec/sum(total.rec))

  # t by s matrix of number of tags recovered in strata t by application strata s
  m.t.rec <- appdat %>%
    filter(Recovery.Sex == "M") %>%
    group_by(!!app.strata, !!rec.strata) %>%
    summarise(tag.recoverd = n()) %>% # this creates a long form version
    spread(!!rec.strata, tag.recoverd) # this changes it to the wide form t by s matrix

    add <- setdiff(m.cor.app[,1], m.t.rec[,1])
    num <- nrow(add)
    if(num >0) m.t.rec[(nrow(m.t.rec)+1):(nrow(m.t.rec)+num), 1] <- add
  
    # need to fill in if any recovery spot in the app strata had a 0, all of the subsetting is to ignore if there are NAs in the app_strata column as it is used as a check to apply secondary mark only recoveries
  m.t.rec[ , 2:ncol(m.t.rec)][is.na(m.t.rec[ , 2:ncol(m.t.rec)])] <- 0
  
  
  # if there are secondary only recoveries the next three blocks will run
  
  # takes the proportion column from m.total.rec and uses matrix multiplication to distribute the number of secondary recoveries from each t strata to a t by s matrix
  if(is.na(m.t.rec[nrow(m.t.rec),1])) secondary.add <- as.matrix(m.total.rec[,3]) %*% 
    as.matrix(m.t.rec[is.na(m.t.rec[,1]) , 2:ncol(m.t.rec)])

  # if there are any NA's because there were no secondary only recoveries in a particular strata, this replaces them with a 0 (I don't know why I had to make an equivelant number of 0s to NAs...)  
  if(is.na(m.t.rec[nrow(m.t.rec),1])) secondary.add[is.na(secondary.add)] <- 
    rep(0, length(secondary.add[is.na(secondary.add)]))

  # adds the secondary correction to the t by s matrix of tag recoveries
  if(is.na(m.t.rec[nrow(m.t.rec),1])) m.t.rec[!is.na(m.t.rec[,1]), 
                                              2:ncol(m.t.rec)] <- m.t.rec[!is.na(m.t.rec[,1]), 
                                                                          2:ncol(m.t.rec)] + secondary.add

    # assembles new R SPAS input matrix & file
  m.spasR <- cbind( m.t.rec[!is.na(m.t.rec[,1]), -1],  m.cor.app[ , -1] - rowSums(m.t.rec[!is.na(m.t.rec[,1]), -1]))
  m.spasR <- as.matrix(rbind(m.spasR, c(t(m.unt.rec[ , -1]), 0)))
  
  write.table(m.spasR, paste("SPAS_R_", name, "_input_Males.csv", sep = ""), 
              row.names = F, col.names = F, sep = ",")
  write.table(m.cor.app[,1], paste("SPAS_R_", name, "ROW_STRATA_NAMES.csv", sep = ""), sep = ",")
 
  # assembles the required columns of the old SPAS 2 (R SPAS) input file AND check
  m.spas2 <- cbind(m.unt.rec[ , -1], m.cor.app[ , -1], m.t.rec[!is.na(m.t.rec[,1]), -1])
  m.spas2 <- as.matrix(m.spas2) # makes it a matrix for easy csv saving with no column names
  
      ####################################################################################################
  #  Dito for Females because looping sum(Untagged.Males) vs. sum(Untagged.Females) doesn't gain much#
  
  f.cor.app <- filter(appdat, Application.Sex == "F") %>% 
    group_by(!!app.strata) %>%
    summarise(applied = n()) %>%
    mutate(applied = applied-sex.cor$applied) # noting that this is substract for females
  
  f.unt.rec <- recdat %>% 
    group_by(!!rec.strata) %>%
    summarise(untagged.rec = sum(Untagged.Females))
  
  f.total.rec <- recdat %>% 
    group_by(!!rec.strata) %>%
    summarise(total.rec = sum(Tagged.Females + Untagged.Females)) %>%
    mutate(pr = total.rec/sum(total.rec))
  
  f.t.rec <- appdat %>%
    filter(Recovery.Sex == "F") %>%
    group_by(!!app.strata, !!rec.strata) %>%
    summarise(tag.recoverd = n()) %>%
    spread(!!rec.strata, tag.recoverd)
  
    add <- setdiff(f.cor.app[,1], f.t.rec[,1])
    num <- nrow(add)
    if(num >0) f.t.rec[(nrow(f.t.rec)+1):(nrow(f.t.rec)+num), 1] <- add
  
    f.t.rec[ , 2:ncol(f.t.rec)][is.na(f.t.rec[ , 2:ncol(f.t.rec)])] <- 0
  
  if(is.na(f.t.rec[nrow(f.t.rec),1])) secondary.add <- as.matrix(f.total.rec[,3]) %*% 
    as.matrix(f.t.rec[is.na(f.t.rec[,1]) , 2:ncol(f.t.rec)])
  
  if(is.na(f.t.rec[nrow(f.t.rec),1])) secondary.add[is.na(secondary.add)] <- 
    rep(0, length(secondary.add[is.na(secondary.add)]))
  
  if(is.na(f.t.rec[nrow(f.t.rec),1])) f.t.rec[!is.na(f.t.rec[,1]), 
                                              2:ncol(f.t.rec)] <- f.t.rec[!is.na(f.t.rec[,1]), 
                                                                          2:ncol(f.t.rec)] + secondary.add
  
  # assembles new R SPAS input matrix & file
  f.spasR <- cbind( f.t.rec[!is.na(f.t.rec[,1]), -1],  f.cor.app[ , -1] - 
                      rowSums(f.t.rec[!is.na(f.t.rec[,1]), -1]))
  f.spasR <- as.matrix(rbind(f.spasR, c(t(f.unt.rec[ , -1]), 0)))
  
    write.table(f.spasR, paste("SPAS_R_", name, "_input_Females.csv", sep = ""), 
              row.names = F, col.names = F, sep = ",")
 
  # assembles the required columns of the old SPAS 2 (R SPAS) input file
  f.spas2 <- cbind(f.unt.rec[ , -1], f.cor.app[ , -1], f.t.rec[!is.na(f.t.rec[,1]), -1])
  f.spas2 <- as.matrix(f.spas2)
     
  ####################################################################################################
  # Print Values for Validating with MACH2
  
  Value <- c("Tags.Applied.M","Tags.Recovered.M","Total.Recovered.M",
             "Tags.Applied.F","Tags.Recovered.F","Total.Recovered.F")
  
  square = TRUE
  
  #simple column or matrix summations to create the validating values described above
  if(square == TRUE) Estimate <- c(sum(m.spas2[,2]), sum(m.spas2[,3:ncol(m.spas2)]), sum(m.spas2[,c(1,3:ncol(m.spas2))]),
                sum(f.spas2[,2]), sum(f.spas2[,3:ncol(f.spas2)]), sum(f.spas2[,c(1,3:ncol(f.spas2))]))
  
  if(square == FALSE) dbl <- nrow(m.spas2)/2 + 1
  
    if(square == FALSE) Estimate <- c(sum(m.spas2[,2]), sum(m.spas2[,3:ncol(m.spas2)]), (sum(m.spas2[,c(1,3:ncol(m.spas2))])-sum(m.spas2[dbl:nrow(m.spas2), 1])),
                sum(f.spas2[,2]), sum(f.spas2[,3:ncol(f.spas2)]), (sum(f.spas2[,c(1,3:ncol(f.spas2))])-sum(f.spas2[dbl:nrow(f.spas2), 1])))
  
  Validate <- data.frame(Value, Estimate)
  
    print(Validate)
    
    ####################################################################################################
  #  Dito for Jacks because looping sum(Untagged.Males) vs. sum(Untagged.Females) doesn't gain much#

        
      # creating applications~app strata  
  if(jacks == TRUE) j.cor.app <- filter(appdat, Application.Sex == "J") %>% 
    group_by(!!app.strata) %>% # creating a row for each app strata
    summarise(applied = n())# n() plus group by does the same thing as count()
      
  
  # create sum of Untagged fish recovered per recovery strata
  if(jacks == TRUE) j.unt.rec <- recdat %>% 
    group_by(!!rec.strata) %>%
    summarise(untagged.rec = sum(Untagged.Jacks))
  
  # create column for total recoveryies and proportion recovered in each strata that will be used for redistributing secondary marked fish to application strata proportional to the recovery strata they were found in
  if(jacks == TRUE) j.total.rec <- recdat %>% 
    group_by(!!rec.strata) %>%
    summarise(total.rec = sum(Tagged.Jacks + Untagged.Jacks)) %>%
    mutate(pr = total.rec/sum(total.rec))

  # t by s matrix of number of tags recovered in strata t by application strata s
  if(jacks == TRUE) j.t.rec <- appdat %>%
    filter(Recovery.Sex == "J") %>%
    group_by(!!app.strata, !!rec.strata) %>%
    summarise(tag.recoverd = n()) %>% # this creates a long form version
    spread(!!rec.strata, tag.recoverd) # this changes it to the wide form t by s matrix
    
    if(jacks == TRUE) add <- setdiff(j.cor.app[,1], j.t.rec[,1])
    if(jacks == TRUE) num <- nrow(add)
    if(jacks == TRUE & num >0) j.t.rec[(nrow(j.t.rec)+1):(nrow(j.t.rec)+num), 1] <- add
      # need to fill in if any recovery spot in the app strata had a 0, all of the subsetting is to ignore if there are NAs in the app_strata column as it is used as a check to apply secondary mark only recoveries
   if(jacks == TRUE) j.t.rec[ , 2:ncol(j.t.rec)][is.na(j.t.rec[ , 2:ncol(j.t.rec)])] <- 0
    
    

  # if there are secondary only recoveries the next three blocks will run
  
  # takes the proportion column from j.total.rec and uses matrix multiplication to distribute the number of secondary recoveries from each t strata to a t by s matrix
  if(jacks == TRUE) if(is.na(j.t.rec[nrow(j.t.rec),1])) secondary.add <- as.matrix(j.total.rec[,3]) %*% 
    as.matrix(j.t.rec[is.na(j.t.rec[,1]) , 2:ncol(j.t.rec)])

  # if there are any NA's because there were no secondary only recoveries in a particular strata, this replaces them with a 0 (I don't know why I had to make an equivelant number of 0s to NAs...)  
  if(jacks == TRUE) if(is.na(j.t.rec[nrow(j.t.rec),1])) secondary.add[is.na(secondary.add)] <- 
    rep(0, length(secondary.add[is.na(secondary.add)]))

  # adds the secondary correction to the t by s matrix of tag recoveries
  if(jacks == TRUE) if(is.na(j.t.rec[nrow(j.t.rec),1])) j.t.rec[!is.na(j.t.rec[,1]), 
                                              2:ncol(j.t.rec)] <- j.t.rec[!is.na(j.t.rec[,1]), 
                                                                          2:ncol(j.t.rec)] + secondary.add

  # assembles new R SPAS input matrix & file
  if(jacks == TRUE) j.spasR <- cbind( j.t.rec[!is.na(j.t.rec[,1]), -1],  j.cor.app[ , -1] - rowSums(j.t.rec[!is.na(j.t.rec[,1]), -1]))
  if(jacks == TRUE) j.spasR <- as.matrix(rbind(j.spasR, c(t(j.unt.rec[ , -1]), 0)))
  
  if(jacks == TRUE) write.table(j.spasR, paste("SPAS_R_", name, "_input_Jacks.csv", sep = ""), 
              row.names = F, col.names = F, sep = ",")
 
}
```

#5 Specify Strata and Corrections
In the chunk below these instructions, do the following:

i) Enter the decided upon strata after the = sign 
for app.strata and rec.strata where it says ENTER_APP_STRATA and ENTER_REC_STRATA

e.g. app.strata = app_equal_days , 
     rec.strata = rec_equal_numbers ,

List of possible choices for app and rec strata:

app_equal_days 
app_equal_effort 
app_equal_numbers
app_equal_area 
app_equal_recaps 
app_equal_extra1

rec_equal_days 
rec_equal_effort 
rec_equal_numbers
rec_equal_area 
rec_equal_extra2


ii) Replace ENTER_NUMBER text withthe Male sex correction factor after the = sign for sex.correction
                          
```{r}
NAME <- "ENTER_A_NAME" # enter the stratification descripter, e.g.spatial or equal_days

SPAS2.input.file(appdat = app, # application data from Section 3, do not change this
                 recdat = rec, # recovery data from Section 3,  do not change this
                 app.strata = ENTER_APP_STRATA , # enter your application strata from the list above
                 # if there are multiple strata, use c(STRATA1, STRATA2) and change combine.app to = TRUE
                 combine.app = FALSE ,
                 rec.strata = ENTER_REC_STRATA , # enter you recovery strata from the list above
                 combine.rec = FALSE,
                 sex.correction = ENTER_NUMBER , # enter the Male sex correction 
                 name = NAME, # don't need to change
                 jacks = FALSE)  # Change to TRUE if you want an file for Jacks
```

Copy and paste the above code if you want to make multiple stratifications

#6 Validate numbers with PopEstimatorPRT in WB5PopEstimator.xlsm

There should be an output in the R Console of 6 values, 
use these values to validate that R has counted or added up the same numbers that correspond in the PopEstimatorPRT sheet int he WB5PopEstimator.xlsm file.

If they don't... something has gone awry.

#7 Locate SPAS2_input.csv(s) in MACH2 folder (working directory) & move to desired folder location

The function automatically created the outputs and placed them in your working directory you chose in Step #2.
They are named SPAS2_input_Males.csv and SPAS2_input_Females.csv
Move them to the desired folder (possibly your SPAS2 analysis folder?) and rename them if desired

#8 Triple Check SPAS2_input.csv(s) by opening them
You can do a triple check here by summing the correct columns to again make sure the sums add to the ones in the MACH2 files.
Just make sure you don't save those column sums!

Taadaa! Your file is ready to be read by SPAS2 (R SPAS)

#9 Load Report Function
Initial code written by Carl
Press the play button and then minimize with the arrow by the line nubmers on the left
DO NOT EDIT unless making a commit to the GitHub
```{r}
# define reporting and removal functions
get.models <- function(pattern){
    # get the list of models according to the pattern specified
    #browser()
    model.list <- mget( ls(envir=globalenv())[grepl(pattern,ls(envir=globalenv()))], envir=globalenv())
    model.list
}


make.report <- function(model.list){
   # make a little report
   report <- plyr::ldply(model.list, function(x){
      #browser()
      data.frame(#version=x$version,
         date   = as.Date(x$date),
         model.id         = x$model.info$model.id,
         AICc             = round(x$model.info$AICc, 3),
         Nhat             = round(x$est$real$N),
         Nhat.se          = round(x$se $real$N),
         s.a.pool         =-1+nrow(x$fit.setup$pooldata),
         t.p.pool         =-1+ncol(x$fit.setup$pooldata),
         logL.cond        = x$model.info$logL.cond,
         np               = x$model.info$np,
         chapman.est      = round(x$est$N.Chapman, 0),
         kappa.pooled     = round(x$kappa.after.lp, 0),
         gof.chisq        = round(x$gof$chisq, 1),
         gof.df           = x$gof$chisq.df,
         gof.p            = round(x$gof$chisq.p, 3)
         )
      
   })
   report <- mutate(report, deltaAIC = round(AICc - min(AICc)), 3) %>% arrange(deltaAIC)
   report <- report[, c(1:3,16,4:15)]
   report
}
```

#10 Run SPAS!
## Read SPAS Input Files
Should just be able to press play to load in whatever was the last dataframe that was created.
The below code also rounds all of the data so integers are going into the SPAS function.
```{r}
(males <- round(as.matrix(read.csv(paste("SPAS_R_", NAME, "_input_Males.csv", sep = ""), header = F)),0)) # rename if you are using multiple stratifications
(females <- round(as.matrix(read.csv(paste("SPAS_R_", NAME, "_input_Females.csv", sep = ""), header = F)),0))
```

## SPAS for Males
Edit the row.pool and col.pool ins to the correct number of strata.
Copy and paste the function if there are additional poolings that are desired. Remember to increase the mod..#
```{r}
modM..1 <- SPAS.fit.model(males, # make sure data frame is correct
                           model.id = "Petersen", # change name to desired description
                       row.pool.in = c(1, 1), # add ,1 if its a 3 x 3
                       # REMEMBER - can only pool rows, NOT columns
                       col.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       theta.pool = FALSE, 
                       CJSpool = FALSE,
                       row.physical.pool=FALSE) # don't change for now

# SPAS.print.model(mod..1) # remove hastag if you want to view the individual result

modM..2 <- SPAS.fit.model(males, # make sure data frame is correct
                             model.id = "Stratified", # change name to desired description
                       row.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       # REMEMBER - can only pool rows, NOT columns
                       col.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       theta.pool = FALSE, 
                       CJSpool = FALSE,
                       row.physical.pool=FALSE) # don't change for now

# SPAS.print.model(mod..2)

# Copy and paste mod..2 until this point if there is another stratification type and edit data going into it and name to mod3


model.list <- get.models("^modM\\.\\.")
report.males <- make.report(model.list)

write.xlsx(report.males, paste(NAME, "_males_report.xlsx", sep = ""), row.names = F, colWidths = "auto")
# can ignore "Note", likely from packages not all being up to date.
```

## SPAS for Females
```{r}
modF..1 <- SPAS.fit.model(females, # make sure data frame is correct
                           model.id = "Petersen", # change name to desired description
                       row.pool.in = c(1, 1), # add ,1 if its a 3 x 3
                       # REMEMBER - can only pool rows, NOT columns
                       col.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       theta.pool = FALSE, 
                       CJSpool = FALSE,
                       row.physical.pool=FALSE) # don't change for now

# SPAS.print.model(mod..1)

modF..2 <- SPAS.fit.model(females, # make sure data frame is correct
                             model.id = "Stratified", # change name to desired description
                       row.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       # REMEMBER - can only pool rows, NOT columns
                       col.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       theta.pool = FALSE, 
                       CJSpool = FALSE,
                       row.physical.pool=FALSE) # don't change for now

# SPAS.print.model(mod..2)

# Copy and paste mod..2 until this point if there is another stratification type and edit data going into it and name to mod3


model.list <- get.models("^modF\\.\\.")
report.females <- make.report(model.list)

write.xlsx(report.females, paste(NAME, "_females_report.xlsx", sep = ""), row.names = F, colWidths = "auto")
```

## SPAS for Jacks
```{r}
modJ..1 <- SPAS.fit.model(jacks, # make sure data frame is correct
                           model.id = "Petersen", # change name to desired description
                       row.pool.in = c(1, 1), # add ,1 if its a 3 x 3
                       # REMEMBER - can only pool rows, NOT columns
                       col.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       theta.pool = FALSE, 
                       CJSpool = FALSE,
                       row.physical.pool=FALSE) # don't change for now

# SPAS.print.model(mod..1)

modJ..2 <- SPAS.fit.model(jacks, # make sure data frame is correct
                             model.id = "Stratified", # change name to desired description
                       row.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       # REMEMBER - can only pool rows, NOT columns
                       col.pool.in = c(1, 2), # add ,3 if its a 3 x 3
                       theta.pool = FALSE, 
                       CJSpool = FALSE,
                       row.physical.pool=FALSE) # don't change for now

# SPAS.print.model(mod..2)

# Copy and paste mod..2 until this point if there is another stratification type and edit data going into it and name to mod3


model.list <- get.models("^modJ\\.\\.")
report.jacks <- make.report(model.list)

write.xlsx(report.jacks, paste(NAME, "_jacks_report.xlsx", sep = ""), row.names = F, colWidths = "auto")
```
